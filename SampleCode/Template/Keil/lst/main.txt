; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;414    
;;;415    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;416    {
;;;417    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH0MFP_Msk)) | (SYS_GPH_MFPL_PH0MFP_GPIO);
000002  f04f4080          MOV      r0,#0x40000000
000006  6e81              LDR      r1,[r0,#0x68]
000008  f021010f          BIC      r1,r1,#0xf
00000c  6681              STR      r1,[r0,#0x68]
;;;418    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH1MFP_Msk)) | (SYS_GPH_MFPL_PH1MFP_GPIO);
00000e  6e81              LDR      r1,[r0,#0x68]
000010  f02101f0          BIC      r1,r1,#0xf0
000014  6681              STR      r1,[r0,#0x68]
;;;419    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH2MFP_Msk)) | (SYS_GPH_MFPL_PH2MFP_GPIO);
000016  6e81              LDR      r1,[r0,#0x68]
000018  f4216170          BIC      r1,r1,#0xf00
00001c  6681              STR      r1,[r0,#0x68]
;;;420    
;;;421    	//EVM LED
;;;422    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
00001e  4c09              LDR      r4,|L1.68|
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_SetMode
;;;423    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00002a  2201              MOVS     r2,#1
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetMode
;;;424    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000034  4620              MOV      r0,r4
000036  2201              MOVS     r2,#1
000038  e8bd4010          POP      {r4,lr}
00003c  2104              MOVS     r1,#4
00003e  f7ffbffe          B.W      GPIO_SetMode
;;;425    	
;;;426    }
;;;427    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000002  0e09              LSRS     r1,r1,#24
000004  2800              CMP      r0,#0                 ;1700
000006  da06              BGE      |L3.22|
000008  f000000f          AND      r0,r0,#0xf
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8801d14          STRB     r1,[r0,#0xd14]
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1707     }
;;;1708   }
000014  4770              BX       lr
                  |L3.22|
000016  f10020e0          ADD      r0,r0,#0xe000e000
00001a  f8801400          STRB     r1,[r0,#0x400]        ;1706
00001e  4770              BX       lr
;;;1709   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;156    
;;;157    void PDMA_IRQHandler(void)
000000  480d              LDR      r0,|L4.56|
;;;158    {
;;;159        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  6800              LDR      r0,[r0,#0]
;;;160    	
;;;161        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000004  07c1              LSLS     r1,r0,#31
000006  d003              BEQ      |L4.16|
;;;162        {
;;;163    		#if 1
;;;164            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
000008  480b              LDR      r0,|L4.56|
00000a  1d00              ADDS     r0,r0,#4
00000c  6801              LDR      r1,[r0,#0]
00000e  e011              B        |L4.52|
                  |L4.16|
;;;165    		#else
;;;166            if (PDMA_GET_ABORT_STS(PDMA) & UART_TX_PDMA_OPENED_CH)
;;;167            {
;;;168            }
;;;169            PDMA_CLR_ABORT_FLAG(PDMA, UART_TX_PDMA_OPENED_CH);
;;;170            if (PDMA_GET_ABORT_STS(PDMA) & (1 << QSPI_MASTER_RX_DMA_CH))
;;;171            {
;;;172            }
;;;173            PDMA_CLR_ABORT_FLAG(PDMA, (1 << QSPI_MASTER_RX_DMA_CH));
;;;174    		#endif
;;;175        }
;;;176        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
000010  0780              LSLS     r0,r0,#30
000012  d510              BPL      |L4.54|
;;;177        {
;;;178            if((PDMA_GET_TD_STS(PDMA) & UART_TX_PDMA_OPENED_CH ) == UART_TX_PDMA_OPENED_CH  )
000014  4808              LDR      r0,|L4.56|
000016  3008              ADDS     r0,r0,#8
000018  6801              LDR      r1,[r0,#0]
00001a  0689              LSLS     r1,r1,#26
00001c  d50b              BPL      |L4.54|
;;;179            {
;;;180                /* Clear PDMA transfer done interrupt flag */
;;;181                PDMA_CLR_TD_FLAG(PDMA, UART_TX_PDMA_OPENED_CH );
00001e  2120              MOVS     r1,#0x20
000020  6001              STR      r1,[r0,#0]
;;;182                
;;;183    			//insert process
;;;184                UART_PDMA_DISABLE(UART_PORT,UART_INTEN_TXPDMAEN_Msk);
000022  4806              LDR      r0,|L4.60|
000024  6841              LDR      r1,[r0,#4]
000026  f4214180          BIC      r1,r1,#0x4000
00002a  6041              STR      r1,[r0,#4]
;;;185                FLAG_UART_TX_FINISH = 1;
00002c  4804              LDR      r0,|L4.64|
00002e  6801              LDR      r1,[r0,#0]  ; flag_PROJ_CTL
000030  f0410104          ORR      r1,r1,#4
                  |L4.52|
000034  6001              STR      r1,[r0,#0]            ;164
                  |L4.54|
;;;186    
;;;187            }  
;;;188        }
;;;189        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;190        {
;;;191            // PDMA_CLR_TMOUT_FLAG(PDMA,UART_TX_DMA_CH);
;;;192        }
;;;193        else
;;;194        {
;;;195            // printf("status : 0x%4X\r\n" ,status);
;;;196        }
;;;197    
;;;198    }
000036  4770              BX       lr
;;;199    
                          ENDP

                  |L4.56|
                          DCD      0x4000841c
                  |L4.60|
                          DCD      0x40074000
                  |L4.64|
                          DCD      ||area_number.32||+0xc

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;427    
;;;428    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;429    {
;;;430        /* Unlock protected registers */
;;;431        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;432    
;;;433        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;434        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000006  f04f2040          MOV      r0,#0x40004000
00000a  f8d01140          LDR      r1,[r0,#0x140]
00000e  f02101f0          BIC      r1,r1,#0xf0
000012  f8c01140          STR      r1,[r0,#0x140]
;;;435        
;;;436        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;437        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;438    
;;;439    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;440    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;441    
;;;442    //    CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
;;;443    //    CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
;;;444    
;;;445    //    CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk);
;;;446    //    CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk);
;;;447    
;;;448        /* Set core clock as PLL_CLOCK from PLL */
;;;449        CLK_SetCoreClock(FREQ_192MHZ);
000022  481f              LDR      r0,|L5.160|
000024  f7fffffe          BL       CLK_SetCoreClock
;;;450        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;451        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV1 | CLK_PCLKDIV_APB1DIV_DIV1);
000028  f04f4480          MOV      r4,#0x40000000
00002c  2500              MOVS     r5,#0
00002e  f8c45234          STR      r5,[r4,#0x234]
;;;452    
;;;453        /* Enable UART clock */
;;;454        CLK_EnableModuleClock(UART0_MODULE);
000032  4e1c              LDR      r6,|L5.164|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       CLK_EnableModuleClock
;;;455        /* Select UART clock source from HXT */
;;;456        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
00003a  2200              MOVS     r2,#0
00003c  f04f7140          MOV      r1,#0x3000000
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       CLK_SetModuleClock
;;;457    
;;;458        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;459        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000046  6be0              LDR      r0,[r4,#0x3c]
000048  f420007f          BIC      r0,r0,#0xff0000
00004c  63e0              STR      r0,[r4,#0x3c]
;;;460        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00004e  6be0              LDR      r0,[r4,#0x3c]
000050  f44000cc          ORR      r0,r0,#0x660000
000054  63e0              STR      r0,[r4,#0x3c]
;;;461    
;;;462        CLK_EnableModuleClock(TMR1_MODULE);
000056  4e14              LDR      r6,|L5.168|
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       CLK_EnableModuleClock
;;;463        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00005e  2200              MOVS     r2,#0
000060  f44f41e0          MOV      r1,#0x7000
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_SetModuleClock
;;;464    
;;;465        CLK_EnableModuleClock(UART4_MODULE);
00006a  4e10              LDR      r6,|L5.172|
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       CLK_EnableModuleClock
;;;466        CLK_SetModuleClock(UART4_MODULE, CLK_CLKSEL3_UART4SEL_HIRC, CLK_CLKDIV4_UART4(1));
000072  2200              MOVS     r2,#0
000074  f04f5140          MOV      r1,#0x30000000
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       CLK_SetModuleClock
;;;467    
;;;468        SYS->GPC_MFPL &= ~(SYS_GPC_MFPL_PC6MFP_Msk | SYS_GPC_MFPL_PC7MFP_Msk);
00007e  6c20              LDR      r0,[r4,#0x40]
000080  f020407f          BIC      r0,r0,#0xff000000
000084  6420              STR      r0,[r4,#0x40]
;;;469        SYS->GPC_MFPL |= (SYS_GPC_MFPL_PC6MFP_UART4_RXD | SYS_GPC_MFPL_PC7MFP_UART4_TXD);
000086  6c20              LDR      r0,[r4,#0x40]
000088  f04040aa          ORR      r0,r0,#0x55000000
00008c  6420              STR      r0,[r4,#0x40]
;;;470    
;;;471        CLK_EnableModuleClock(PDMA_MODULE);
00008e  2001              MOVS     r0,#1
000090  f7fffffe          BL       CLK_EnableModuleClock
;;;472    
;;;473        /* Update System Core Clock */
;;;474        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;475        SystemCoreClockUpdate();
000094  f7fffffe          BL       SystemCoreClockUpdate
000098  f8c45100          STR      r5,[r4,#0x100]
;;;476    
;;;477        /* Lock protected registers */
;;;478        SYS_LockReg();
;;;479    }
00009c  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

00009e  0000              DCW      0x0000
                  |L5.160|
                          DCD      0x0b71b000
                  |L5.164|
                          DCD      0x57803d10
                  |L5.168|
                          DCD      0x5ec00003
                  |L5.172|
                          DCD      0x77cc3d14

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2216              MOVS     r2,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  2388              MOVS     r3,#0x88
                  |L6.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;1590
00000e  f8c02100          STR      r2,[r0,#0x100]        ;1591
000012  f8c03100          STR      r3,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L6.10|
;;;1595   }
00001e  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;58     
;;;59     void SysTick_Handler(void)
000000  b500              PUSH     {lr}
;;;60     {
;;;61     
;;;62         systick_counter();
000002  f7fffffe          BL       systick_counter
000006  4903              LDR      r1,|L7.20|
000008  6808              LDR      r0,[r1,#0]  ; counter_systick
00000a  1c40              ADDS     r0,r0,#1
;;;63     
;;;64         if (get_systick() >= 0xFFFFFFFF)
00000c  d100              BNE      |L7.16|
00000e  6008              STR      r0,[r1,#0]  ; counter_systick
                  |L7.16|
;;;65         {
;;;66             set_systick(0);      
;;;67         }
;;;68     
;;;69         // if ((get_systick() % 1000) == 0)
;;;70         // {
;;;71            
;;;72         // }
;;;73     
;;;74         #if defined (ENABLE_TICK_EVENT)
;;;75         TickCheckTickEvent();
;;;76         #endif    
;;;77     }
000010  bd00              POP      {pc}
;;;78     
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      ||area_number.32||

                          AREA ||i.SysTick_delay||, CODE, READONLY, ALIGN=2

                  SysTick_delay PROC
;;;78     
;;;79     void SysTick_delay(unsigned int delay)
000000  4903              LDR      r1,|L8.16|
000002  680a              LDR      r2,[r1,#0]  ; counter_systick
                  |L8.4|
000004  680b              LDR      r3,[r1,#0]  ; counter_systick
;;;80     {  
;;;81         
;;;82         unsigned int tickstart = get_systick(); 
;;;83         unsigned int wait = delay; 
;;;84     
;;;85         while((get_systick() - tickstart) < wait) 
000006  1a9b              SUBS     r3,r3,r2
000008  4283              CMP      r3,r0
00000a  d3fb              BCC      |L8.4|
;;;86         { 
;;;87         } 
;;;88     
;;;89     }
00000c  4770              BX       lr
;;;90     
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      ||area_number.32||

                          AREA ||i.SysTick_enable||, CODE, READONLY, ALIGN=2

                  SysTick_enable PROC
;;;90     
;;;91     void SysTick_enable(unsigned int ticks_per_second)
000000  4a0d              LDR      r2,|L9.56|
;;;92     {
000002  b510              PUSH     {r4,lr}
;;;93         set_systick(0);
000004  2100              MOVS     r1,#0
000006  6011              STR      r1,[r2,#0]  ; counter_systick
;;;94         if (SysTick_Config(SystemCoreClock / ticks_per_second))
000008  490c              LDR      r1,|L9.60|
00000a  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  1e40              SUBS     r0,r0,#1
000012  f1b07f80          CMP      r0,#0x1000000
000016  d303              BCC      |L9.32|
;;;95         {
;;;96             /* Setup SysTick Timer for 1 second interrupts  */
;;;97             printf("Set system tick error!!\n");
000018  a009              ADR      r0,|L9.64|
00001a  f7fffffe          BL       __2printf
                  |L9.30|
;;;98             while (1);
00001e  e7fe              B        |L9.30|
                  |L9.32|
000020  f04f24e0          MOV      r4,#0xe000e000
000024  6160              STR      r0,[r4,#0x14]
000026  210f              MOVS     r1,#0xf
000028  1760              ASRS     r0,r4,#29
00002a  f7fffffe          BL       NVIC_SetPriority
00002e  2000              MOVS     r0,#0
000030  61a0              STR      r0,[r4,#0x18]
000032  2007              MOVS     r0,#7
000034  6120              STR      r0,[r4,#0x10]
;;;99         }
;;;100    
;;;101        #if defined (ENABLE_TICK_EVENT)
;;;102        TickInitTickEvent();
;;;103        #endif
;;;104    }
000036  bd10              POP      {r4,pc}
;;;105    
                          ENDP

                  |L9.56|
                          DCD      ||area_number.32||
                  |L9.60|
                          DCD      SystemCoreClock
                  |L9.64|
000040  53657420          DCB      "Set system tick error!!\n",0
000044  73797374
000048  656d2074
00004c  69636b20
000050  6572726f
000054  7221210a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;148    
;;;149    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;150    {
;;;151        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L10.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;152        TIMER_EnableInt(TIMER1);
;;;153        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;154        TIMER_Start(TIMER1);
;;;155    }
000028  bd10              POP      {r4,pc}
;;;156    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;123    }
;;;124    void TMR1_IRQHandler(void)
000000  4813              LDR      r0,|L11.80|
;;;125    {
000002  b510              PUSH     {r4,lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d01f              BEQ      |L11.78|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;126    	
;;;127        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;128        {
;;;129            TIMER_ClearIntFlag(TIMER1);
;;;130    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4b0f              LDR      r3,|L11.84|
000018  6858              LDR      r0,[r3,#4]  ; counter_tick
;;;131    
;;;132    		if ((get_tick() % 1000) == 0)
00001a  f44f717a          MOV      r1,#0x3e8
00001e  fbb0f2f1          UDIV     r2,r0,r1
000022  fb010012          MLS      r0,r1,r2,r0
;;;133    		{
;;;134                FLAG_PROJ_TIMER_PERIOD_1000MS = 1;//set_flag(flag_timer_period_1000ms ,ENABLE);
000026  f103020c          ADD      r2,r3,#0xc
00002a  b918              CBNZ     r0,|L11.52|
00002c  6810              LDR      r0,[r2,#0]  ; flag_PROJ_CTL
00002e  f0400001          ORR      r0,r0,#1
000032  6010              STR      r0,[r2,#0]  ; flag_PROJ_CTL
                  |L11.52|
000034  6858              LDR      r0,[r3,#4]  ; counter_tick
;;;135    		}
;;;136    
;;;137    		if ((get_tick() % 500) == 0)
000036  f44f71fa          MOV      r1,#0x1f4
00003a  fbb0f4f1          UDIV     r4,r0,r1
00003e  fb010014          MLS      r0,r1,r4,r0
000042  b918              CBNZ     r0,|L11.76|
;;;138    		{
;;;139                FLAG_PROJ_TIMER_PERIOD_500MS = 1;
000044  6810              LDR      r0,[r2,#0]  ; flag_PROJ_CTL
000046  f0400002          ORR      r0,r0,#2
00004a  6010              STR      r0,[r2,#0]  ; flag_PROJ_CTL
                  |L11.76|
00004c  6858              LDR      r0,[r3,#4]  ; counter_tick
                  |L11.78|
;;;140    		}
;;;141    		
;;;142    		if ((get_tick() % 50) == 0)
;;;143    		{
;;;144    
;;;145    		}	
;;;146        }
;;;147    }
00004e  bd10              POP      {r4,pc}
;;;148    
                          ENDP

                  |L11.80|
                          DCD      0x40050100
                  |L11.84|
                          DCD      ||area_number.32||

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;354    
;;;355    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;356    {
;;;357        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L12.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L12.18|
00000c  e004              B        |L12.24|
                  |L12.14|
;;;358        {
;;;359            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;360            {
;;;361    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L12.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;359
000014  0449              LSLS     r1,r1,#17             ;359
000016  d5fa              BPL      |L12.14|
                  |L12.24|
;;;362            }
;;;363        }
;;;364    
;;;365        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L12.46|
;;;366        {
;;;367            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L12.46|
;;;368        }	
;;;369    }
00002e  bd10              POP      {r4,pc}
;;;370    
                          ENDP

                  |L12.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;370    
;;;371    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;372    {
;;;373        SYS_ResetModule(UART0_RST);
000002  4824              LDR      r0,|L13.148|
000004  f7fffffe          BL       SYS_ResetModule
;;;374    
;;;375        /* Configure UART0 and set UART0 baud rate */
;;;376        UART_Open(UART0, 115200);
000008  4c23              LDR      r4,|L13.152|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;377    
;;;378    	/* Set UART receive time-out */
;;;379    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;380    
;;;381    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;382    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;383    
;;;384    	/* Enable UART Interrupt - */
;;;385    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;386    	
;;;387    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;388    
;;;389    	#if (_debug_log_UART_ == 1)	//debug
;;;390    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a016              ADR      r0,|L13.156|
000044  f7fffffe          BL       __2printf
;;;391    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());
000048  f7fffffe          BL       CLK_GetHCLKFreq
00004c  4601              MOV      r1,r0
00004e  a01a              ADR      r0,|L13.184|
000050  f7fffffe          BL       __2printf
;;;392    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000054  f7fffffe          BL       CLK_GetHXTFreq
000058  4601              MOV      r1,r0
00005a  a01d              ADR      r0,|L13.208|
00005c  f7fffffe          BL       __2printf
;;;393    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000060  f7fffffe          BL       CLK_GetLXTFreq
000064  4601              MOV      r1,r0
000066  a020              ADR      r0,|L13.232|
000068  f7fffffe          BL       __2printf
;;;394    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00006c  f7fffffe          BL       CLK_GetPCLK0Freq
000070  4601              MOV      r1,r0
000072  a023              ADR      r0,|L13.256|
000074  f7fffffe          BL       __2printf
;;;395    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000078  f7fffffe          BL       CLK_GetPCLK1Freq
00007c  4601              MOV      r1,r0
00007e  a027              ADR      r0,|L13.284|
000080  f7fffffe          BL       __2printf
;;;396    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());    	
000084  f7fffffe          BL       CLK_GetHCLKFreq
000088  4601              MOV      r1,r0
00008a  e8bd4010          POP      {r4,lr}
00008e  a00a              ADR      r0,|L13.184|
000090  f7ffbffe          B.W      __2printf
;;;397    
;;;398    //    printf("Product ID 0x%8X\n", SYS->PDID);
;;;399    	
;;;400    	#endif	
;;;401    
;;;402        #if 0
;;;403        printf("FLAG_PROJ_TIMER_PERIOD_1000MS : 0x%2X\r\n",FLAG_PROJ_TIMER_PERIOD_1000MS);
;;;404        printf("FLAG_PROJ_REVERSE1 : 0x%2X\r\n",FLAG_PROJ_REVERSE1);
;;;405        printf("FLAG_PROJ_REVERSE2 : 0x%2X\r\n",FLAG_PROJ_REVERSE2);
;;;406        printf("FLAG_PROJ_REVERSE3 : 0x%2X\r\n",FLAG_PROJ_REVERSE3);
;;;407        printf("FLAG_PROJ_REVERSE4 : 0x%2X\r\n",FLAG_PROJ_REVERSE4);
;;;408        printf("FLAG_PROJ_REVERSE5 : 0x%2X\r\n",FLAG_PROJ_REVERSE5);
;;;409        printf("FLAG_PROJ_REVERSE6 : 0x%2X\r\n",FLAG_PROJ_REVERSE6);
;;;410        printf("FLAG_PROJ_REVERSE7 : 0x%2X\r\n",FLAG_PROJ_REVERSE7);
;;;411        #endif
;;;412    
;;;413    }
;;;414    
                          ENDP

                  |L13.148|
                          DCD      0x04000010
                  |L13.152|
                          DCD      0x40070000
                  |L13.156|
00009c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000a0  4b5f4765
0000a4  74435055
0000a8  46726571
0000ac  203a2025
0000b0  38640d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L13.184|
0000b8  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000bc  47657448
0000c0  434c4b46
0000c4  72657120
0000c8  3a202538
0000cc  640d0a00
                  |L13.208|
0000d0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000d4  47657448
0000d8  58544672
0000dc  6571203a
0000e0  20253864
0000e4  0d0a00  
0000e7  00                DCB      0
                  |L13.232|
0000e8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000ec  4765744c
0000f0  58544672
0000f4  6571203a
0000f8  20253864
0000fc  0d0a00  
0000ff  00                DCB      0
                  |L13.256|
000100  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
000104  47657450
000108  434c4b30
00010c  46726571
000110  203a2025
000114  38640d0a
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L13.284|
00011c  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
000120  47657450
000124  434c4b31
000128  46726571
00012c  203a2025
000130  38640d0a
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||i.UART_PDMA_Init||, CODE, READONLY, ALIGN=2

                  UART_PDMA_Init PROC
;;;255    
;;;256    void UART_PDMA_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
;;;258    
;;;259        FLAG_UART_TX_FINISH = 0;
000002  4818              LDR      r0,|L14.100|
;;;260    
;;;261        UART_Open(UART_PORT, 115200);
000004  4d18              LDR      r5,|L14.104|
000006  6801              LDR      r1,[r0,#0]            ;259  ; flag_PROJ_CTL
000008  f0210104          BIC      r1,r1,#4              ;259
00000c  6001              STR      r1,[r0,#0]  ; flag_PROJ_CTL
00000e  f44f31e1          MOV      r1,#0x1c200
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       UART_Open
;;;262    
;;;263        PDMA_Open(PDMA, UART_TX_PDMA_OPENED_CH);
000018  4c14              LDR      r4,|L14.108|
00001a  2120              MOVS     r1,#0x20
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       PDMA_Open
;;;264    
;;;265        PDMA_SetBurstType(PDMA,UART_TX_DMA_CH, PDMA_REQ_SINGLE, PDMA_BURST_128);
000022  2300              MOVS     r3,#0
000024  2204              MOVS     r2,#4
000026  2105              MOVS     r1,#5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       PDMA_SetBurstType
;;;266        /* Disable table interrupt */
;;;267        PDMA->DSCT[UART_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00002e  6d20              LDR      r0,[r4,#0x50]
000030  f0400080          ORR      r0,r0,#0x80
000034  6520              STR      r0,[r4,#0x50]
;;;268    
;;;269    	UART_PDMA_DISABLE(UART_PORT,UART_INTEN_TXPDMAEN_Msk);        
000036  6868              LDR      r0,[r5,#4]
000038  f4204080          BIC      r0,r0,#0x4000
00003c  6068              STR      r0,[r5,#4]
;;;270    
;;;271        #if defined (ENALBE_PDMA_IRQ)
;;;272        PDMA_EnableInt(PDMA, UART_TX_DMA_CH, PDMA_INT_TRANS_DONE);
00003e  2200              MOVS     r2,#0
000040  2105              MOVS     r1,#5
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       PDMA_EnableInt
;;;273    
;;;274        NVIC_SetPriority(PDMA_IRQn,0);
000048  2100              MOVS     r1,#0
00004a  2028              MOVS     r0,#0x28
00004c  f7fffffe          BL       NVIC_SetPriority
000050  4907              LDR      r1,|L14.112|
000052  15a0              ASRS     r0,r4,#22
000054  f8c10280          STR      r0,[r1,#0x280]
;;;275        NVIC_ClearPendingIRQ(PDMA_IRQn);
;;;276        NVIC_EnableIRQ(PDMA_IRQn);
000058  e8bd4070          POP      {r4-r6,lr}
00005c  2028              MOVS     r0,#0x28
00005e  f7ffbffe          B.W      NVIC_EnableIRQ
;;;277        #endif
;;;278    
;;;279    }
;;;280    
                          ENDP

000062  0000              DCW      0x0000
                  |L14.100|
                          DCD      ||area_number.32||+0xc
                  |L14.104|
                          DCD      0x40074000
                  |L14.108|
                          DCD      0x40008000
                  |L14.112|
                          DCD      0xe000e004

                          AREA ||i.UART_TX_PDMA||, CODE, READONLY, ALIGN=2

                  UART_TX_PDMA PROC
;;;199    
;;;200    void UART_TX_PDMA(uint8_t* Datain , uint16_t len)
000000  b57c              PUSH     {r2-r6,lr}
;;;201    {
;;;202        #if defined (ENALBE_PDMA_POLLING)      
;;;203    	uint32_t u32RegValue = 0;
;;;204    	uint32_t u32Abort = 0;	
;;;205        static uint8_t cnt = 0;    
;;;206        #endif
;;;207    
;;;208        FLAG_UART_TX_FINISH = 0;
000002  4c14              LDR      r4,|L15.84|
000004  4605              MOV      r5,r0                 ;201
;;;209    	
;;;210    	//U
;;;211        PDMA_SetTransferCnt(PDMA,UART_TX_DMA_CH, PDMA_WIDTH_8, len);
000006  4e14              LDR      r6,|L15.88|
000008  6820              LDR      r0,[r4,#0]            ;208  ; flag_PROJ_CTL
00000a  460b              MOV      r3,r1
00000c  f0200004          BIC      r0,r0,#4              ;208
000010  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
000012  2200              MOVS     r2,#0
000014  2105              MOVS     r1,#5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       PDMA_SetTransferCnt
;;;212        /* Set source/destination address and attributes */
;;;213        PDMA_SetTransferAddr(PDMA,UART_TX_DMA_CH, (uint32_t) (&Datain[0]), PDMA_SAR_INC, (uint32_t) UART4_BASE , PDMA_DAR_FIX);
00001c  f44f6040          MOV      r0,#0xc00
000020  4c0e              LDR      r4,|L15.92|
000022  e9cd4000          STRD     r4,r0,[sp,#0]
000026  2300              MOVS     r3,#0
000028  462a              MOV      r2,r5
00002a  2105              MOVS     r1,#5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       PDMA_SetTransferAddr
;;;214        /* Set request source; set basic mode. */
;;;215    
;;;216        PDMA_SetTransferMode(PDMA,UART_TX_DMA_CH, PDMA_UART4_TX, FALSE, 0);
000032  2000              MOVS     r0,#0
000034  4603              MOV      r3,r0
000036  9000              STR      r0,[sp,#0]
000038  220c              MOVS     r2,#0xc
00003a  2105              MOVS     r1,#5
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       PDMA_SetTransferMode
;;;217    
;;;218    	UART_PDMA_ENABLE(UART_PORT,UART_INTEN_TXPDMAEN_Msk);
000042  6860              LDR      r0,[r4,#4]
000044  f4404080          ORR      r0,r0,#0x4000
000048  6060              STR      r0,[r4,#4]
                  |L15.74|
;;;219    
;;;220        #if defined (ENALBE_PDMA_POLLING)   
;;;221        while(1)
;;;222        {
;;;223            /* Get interrupt status */
;;;224            u32RegValue = PDMA_GET_INT_STATUS(PDMA);
;;;225            /* Check the DMA transfer done interrupt flag */
;;;226            if(u32RegValue & PDMA_INTSTS_TDIF_Msk)
;;;227            {
;;;228                /* Check the PDMA transfer done interrupt flags */
;;;229                if((PDMA_GET_TD_STS(PDMA) & UART_TX_PDMA_OPENED_CH) == UART_TX_PDMA_OPENED_CH)
;;;230                {
;;;231                    /* Clear the DMA transfer done flags */
;;;232                    PDMA_CLR_TD_FLAG(PDMA , UART_TX_PDMA_OPENED_CH);
;;;233    
;;;234                    UART_PDMA_DISABLE(UART_PORT,UART_INTEN_TXPDMAEN_Msk);
;;;235                    FLAG_UART_TX_FINISH = 1;
;;;236                    break;              
;;;237                }
;;;238            }
;;;239            /* Check the DMA transfer abort interrupt flag */
;;;240            if(u32RegValue & PDMA_INTSTS_ABTIF_Msk)
;;;241            {
;;;242                /* Get the target abort flag */
;;;243                u32Abort = PDMA_GET_ABORT_STS(PDMA);
;;;244                /* Clear the target abort flag */
;;;245                PDMA_CLR_ABORT_FLAG(PDMA,u32Abort);
;;;246                break;
;;;247            }		
;;;248        }
;;;249        #endif
;;;250    
;;;251        // while(!FLAG_UART_TX_FINISH);
;;;252        while(!UART_IS_TX_EMPTY(UART_PORT));
00004a  69a0              LDR      r0,[r4,#0x18]
00004c  00c0              LSLS     r0,r0,#3
00004e  d5fc              BPL      |L15.74|
;;;253    
;;;254    }
000050  bd7c              POP      {r2-r6,pc}
;;;255    
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      ||area_number.32||+0xc
                  |L15.88|
                          DCD      0x40008000
                  |L15.92|
                          DCD      0x40074000

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  UARTx_Process PROC
;;;324    
;;;325    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;326    {
;;;327    	uint8_t res = 0;
;;;328    	res = UART_READ(UART0);
000002  4810              LDR      r0,|L16.68|
000004  6800              LDR      r0,[r0,#0]
000006  b2c4              UXTB     r4,r0
;;;329    
;;;330    	if (res > 0x7F)
000008  2c7f              CMP      r4,#0x7f
00000a  d904              BLS      |L16.22|
;;;331    	{
;;;332    		printf("invalid command\r\n");
00000c  e8bd4010          POP      {r4,lr}
000010  a00d              ADR      r0,|L16.72|
000012  f7ffbffe          B.W      __2printf
                  |L16.22|
;;;333    	}
;;;334    	else
;;;335    	{
;;;336    		printf("press : %c\r\n" , res);
000016  4621              MOV      r1,r4
000018  a010              ADR      r0,|L16.92|
00001a  f7fffffe          BL       __2printf
;;;337    		switch(res)
00001e  2c5a              CMP      r4,#0x5a
000020  d009              BEQ      |L16.54|
000022  dc04              BGT      |L16.46|
000024  2c31              CMP      r4,#0x31
000026  d00c              BEQ      |L16.66|
000028  2c58              CMP      r4,#0x58
00002a  d10a              BNE      |L16.66|
00002c  e003              B        |L16.54|
                  |L16.46|
00002e  2c78              CMP      r4,#0x78
000030  d001              BEQ      |L16.54|
000032  2c7a              CMP      r4,#0x7a
000034  d105              BNE      |L16.66|
                  |L16.54|
;;;338    		{
;;;339    			case '1':
;;;340    				break;
;;;341    
;;;342    			case 'X':
;;;343    			case 'x':
;;;344    			case 'Z':
;;;345    			case 'z':
;;;346                    SYS_UnlockReg();
000036  f7fffffe          BL       SYS_UnlockReg
;;;347    				// NVIC_SystemReset();	// Reset I/O and peripherals , only check BS(FMC_ISPCTL[1])
;;;348                    // SYS_ResetCPU();     // Not reset I/O and peripherals
;;;349                    SYS_ResetChip();    // Reset I/O and peripherals ,  BS(FMC_ISPCTL[1]) reload from CONFIG setting (CBS)	
00003a  e8bd4010          POP      {r4,lr}
00003e  f7ffbffe          B.W      SYS_ResetChip
                  |L16.66|
;;;350    				break;
;;;351    		}
;;;352    	}
;;;353    }
000042  bd10              POP      {r4,pc}
;;;354    
                          ENDP

                  |L16.68|
                          DCD      0x40070000
                  |L16.72|
000048  696e7661          DCB      "invalid command\r\n",0
00004c  6c696420
000050  636f6d6d
000054  616e640d
000058  0a00    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L16.92|
00005c  70726573          DCB      "press : %c\r\n",0
000060  73203a20
000064  25630d0a
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.create_buffer||, CODE, READONLY, ALIGN=2

                  create_buffer PROC
;;;280    
;;;281    void create_buffer(void)
000000  4906              LDR      r1,|L17.28|
;;;282    {
;;;283        uint16_t i = 0;  
000002  2000              MOVS     r0,#0
                  |L17.4|
;;;284        for (i = 0 ; i < (TXBUFSIZE/2) ; i++)
;;;285        {
;;;286            tBuffer[i*2+0] = HIBYTE(i);
000004  0a02              LSRS     r2,r0,#8
000006  f8012010          STRB     r2,[r1,r0,LSL #1]
;;;287            tBuffer[i*2+1] = LOBYTE(i);
00000a  eb010240          ADD      r2,r1,r0,LSL #1
00000e  7050              STRB     r0,[r2,#1]
000010  1c40              ADDS     r0,r0,#1
000012  b280              UXTH     r0,r0                 ;284
000014  2810              CMP      r0,#0x10              ;284
000016  d3f5              BCC      |L17.4|
;;;288        }    
;;;289    }
000018  4770              BX       lr
;;;290    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      ||.bss||

                          AREA ||i.get_systick||, CODE, READONLY, ALIGN=2

                  get_systick PROC
;;;43     
;;;44     unsigned int get_systick(void)
000000  4801              LDR      r0,|L18.8|
;;;45     {
;;;46     	return (counter_systick);
000002  6800              LDR      r0,[r0,#0]  ; counter_systick
;;;47     }
000004  4770              BX       lr
;;;48     
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      ||area_number.32||

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;105    
;;;106    uint32_t get_tick(void)
000000  4801              LDR      r0,|L19.8|
;;;107    {
;;;108    	return (counter_tick);
000002  6840              LDR      r0,[r0,#4]  ; counter_tick
;;;109    }
000004  4770              BX       lr
;;;110    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      ||area_number.32||

                          AREA ||i.loop||, CODE, READONLY, ALIGN=2

                  loop PROC
;;;290    
;;;291    void loop(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4d12              LDR      r5,|L20.76|
000004  6828              LDR      r0,[r5,#0]  ; counter_systick
;;;292    {
;;;293    	// static uint32_t LOG1 = 0;
;;;294    	// static uint32_t LOG2 = 0;
;;;295    	static uint32_t cnt = 0;  
;;;296    
;;;297        if ((get_systick() % 1000) == 0)
;;;298        {
;;;299            // printf("%s(systick) : %4d\r\n",__FUNCTION__,LOG2++);    
;;;300        }
;;;301    
;;;302        if (FLAG_PROJ_TIMER_PERIOD_500MS)
000006  f105040c          ADD      r4,r5,#0xc
00000a  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
00000c  0781              LSLS     r1,r0,#30
00000e  d511              BPL      |L20.52|
;;;303        {
;;;304            FLAG_PROJ_TIMER_PERIOD_500MS = 0;
000010  f0200002          BIC      r0,r0,#2
;;;305    
;;;306            tBuffer[0] = 0x5A;
000014  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
000016  480e              LDR      r0,|L20.80|
000018  215a              MOVS     r1,#0x5a
00001a  7001              STRB     r1,[r0,#0]
;;;307            tBuffer[1] = 0x5A;      
00001c  7041              STRB     r1,[r0,#1]
;;;308            tBuffer[TXBUFSIZE-3] = cnt;         
00001e  7a29              LDRB     r1,[r5,#8]  ; cnt
000020  7741              STRB     r1,[r0,#0x1d]
;;;309            tBuffer[TXBUFSIZE-2] = 0xA5;        
000022  21a5              MOVS     r1,#0xa5
000024  7781              STRB     r1,[r0,#0x1e]
;;;310            tBuffer[TXBUFSIZE-1] = 0xA5;
000026  77c1              STRB     r1,[r0,#0x1f]
;;;311            
;;;312    		UART_TX_PDMA(tBuffer , TXBUFSIZE);
000028  2120              MOVS     r1,#0x20
00002a  f7fffffe          BL       UART_TX_PDMA
;;;313            cnt++;
00002e  68a8              LDR      r0,[r5,#8]  ; cnt
000030  1c40              ADDS     r0,r0,#1
000032  60a8              STR      r0,[r5,#8]  ; cnt
                  |L20.52|
;;;314        }
;;;315    
;;;316        if (FLAG_PROJ_TIMER_PERIOD_1000MS)
000034  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
000036  07c1              LSLS     r1,r0,#31
000038  d007              BEQ      |L20.74|
;;;317        {
;;;318            FLAG_PROJ_TIMER_PERIOD_1000MS = 0;
00003a  f0200001          BIC      r0,r0,#1
;;;319    
;;;320            // printf("%s(timer) : %4d\r\n",__FUNCTION__,LOG1++);
;;;321            PH0 ^= 1;
00003e  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
000040  4804              LDR      r0,|L20.84|
000042  6801              LDR      r1,[r0,#0]
000044  f0810101          EOR      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L20.74|
;;;322        }
;;;323    }
00004a  bd70              POP      {r4-r6,pc}
;;;324    
                          ENDP

                  |L20.76|
                          DCD      ||area_number.32||
                  |L20.80|
                          DCD      ||.bss||
                  |L20.84|
                          DCD      0x400049c0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;488    
;;;489    int main()
000000  f7fffffe          BL       SYS_Init
;;;490    {
;;;491        SYS_Init();
;;;492    
;;;493    	GPIO_Init();
000004  f7fffffe          BL       GPIO_Init
;;;494    	UART0_Init();
000008  f7fffffe          BL       UART0_Init
;;;495    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;496    
;;;497        SysTick_enable(1000);
000010  f44f707a          MOV      r0,#0x3e8
000014  f7fffffe          BL       SysTick_enable
;;;498        #if defined (ENABLE_TICK_EVENT)
;;;499        TickSetTickEvent(1000, TickCallback_processA);  // 1000 ms
;;;500        TickSetTickEvent(5000, TickCallback_processB);  // 5000 ms
;;;501        #endif
;;;502    
;;;503        UART_PDMA_Init();
000018  f7fffffe          BL       UART_PDMA_Init
;;;504        create_buffer();
00001c  f7fffffe          BL       create_buffer
                  |L21.32|
;;;505    
;;;506        /* Got no where to go, just loop forever */
;;;507        while(1)
;;;508        {
;;;509            loop();
000020  f7fffffe          BL       loop
000024  e7fc              B        |L21.32|
;;;510    
;;;511        }
;;;512    }
;;;513    
                          ENDP


                          AREA ||i.set_systick||, CODE, READONLY, ALIGN=2

                  set_systick PROC
;;;48     
;;;49     void set_systick(unsigned int t)
000000  4901              LDR      r1,|L22.8|
;;;50     {
;;;51     	counter_systick = t;
000002  6008              STR      r0,[r1,#0]  ; counter_systick
;;;52     }
000004  4770              BX       lr
;;;53     
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      ||area_number.32||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;110    
;;;111    void set_tick(uint32_t t)
000000  4901              LDR      r1,|L23.8|
;;;112    {
;;;113    	counter_tick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_tick
;;;114    }
000004  4770              BX       lr
;;;115    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      ||area_number.32||

                          AREA ||i.systick_counter||, CODE, READONLY, ALIGN=2

                  systick_counter PROC
;;;53     
;;;54     void systick_counter(void)
000000  4802              LDR      r0,|L24.12|
;;;55     {
;;;56     	counter_systick++;
000002  6801              LDR      r1,[r0,#0]  ; counter_systick
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; counter_systick
;;;57     }
000008  4770              BX       lr
;;;58     
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      ||area_number.32||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;115    
;;;116    void tick_counter(void)
000000  4805              LDR      r0,|L25.24|
;;;117    {
;;;118    	counter_tick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_tick
000008  6841              LDR      r1,[r0,#4]  ; counter_tick
;;;119        if (get_tick() >= 60000)
00000a  f64e2260          MOV      r2,#0xea60
00000e  4291              CMP      r1,r2
000010  d301              BCC      |L25.22|
;;;120        {
;;;121            set_tick(0);
000012  2100              MOVS     r1,#0
000014  6041              STR      r1,[r0,#4]  ; counter_tick
                  |L25.22|
;;;122        }
;;;123    }
000016  4770              BX       lr
;;;124    void TMR1_IRQHandler(void)
                          ENDP

                  |L25.24|
                          DCD      ||area_number.32||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  tBuffer
                          %        32

                          AREA ||area_number.28||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.bss||
                  DMA_DESC
                          %        32

                          AREA ||.data||, DATA, ALIGN=0

                  u8TxIdx
000000  00                DCB      0x00

                          AREA ||area_number.31||, DATA, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.data||
                  g_u32DMAConfig
                          DCD      0x00000000

                          AREA ||area_number.32||, DATA, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.data||
                  counter_systick
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  ||cnt||
                          DCD      0x00000000
                  flag_PROJ_CTL
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_tBuffer____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_tBuffer____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_tBuffer____REVSH|
#line 402
|__asm___6_main_c_tBuffer____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_tBuffer____RRX|
#line 587
|__asm___6_main_c_tBuffer____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
