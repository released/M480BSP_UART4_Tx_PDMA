; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;31       */
;;;32     void CLK_DisableCKO(void)
000000  4801              LDR      r0,|L1.8|
;;;33     {
;;;34         /* Disable CKO clock source */
;;;35         CLK_DisableModuleClock(CLKO_MODULE);
000002  f7ffbffe          B.W      CLK_DisableModuleClock
;;;36     }
;;;37     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x57c00006

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;769      */
;;;770    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;771    {
;;;772        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;773    
;;;774        u32tmpVal = ~(1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;775        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L2.24|
;;;776        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;777    
;;;778        *(uint32_t *)u32tmpAddr &= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  438a              BICS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;779    }
000016  4770              BX       lr
;;;780    
                          ENDP

                  |L2.24|
                          DCD      0x40000204

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=1

                  CLK_DisablePLL PROC
;;;944      */
;;;945    void CLK_DisablePLL(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;946    {
;;;947        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000004  f8d01240          LDR      r1,[r0,#0x240]
000008  f4413180          ORR      r1,r1,#0x10000
00000c  f8c01240          STR      r1,[r0,#0x240]
;;;948    }
000010  4770              BX       lr
;;;949    
                          ENDP


                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_DisableSysTick PROC
;;;1029     */
;;;1030   void CLK_DisableSysTick(void)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;1031   {
;;;1032       /* Set System Tick counter disabled */
;;;1033       SysTick->CTRL = 0UL;
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
;;;1034   }
000008  4770              BX       lr
;;;1035   
                          ENDP


                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_DisableXtalRC PROC
;;;609      */
;;;610    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;611    {
;;;612        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4382              BICS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;613    }
00000e  4770              BX       lr
;;;614    
                          ENDP


                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;54       */
;;;55     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  4603              MOV      r3,r0
;;;56     {
;;;57         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;58         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | (u32ClkDiv) | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  ea411042          ORR      r0,r1,r2,LSL #5
000006  b510              PUSH     {r4,lr}               ;56
000008  f04f4280          MOV      r2,#0x40000000
00000c  f0400110          ORR      r1,r0,#0x10
000010  f8c21260          STR      r1,[r2,#0x260]
;;;59     
;;;60         /* Enable CKO clock source */
;;;61         CLK_EnableModuleClock(CLKO_MODULE);
000014  4c05              LDR      r4,|L6.44|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       CLK_EnableModuleClock
;;;62     
;;;63         /* Select CKO clock source */
;;;64         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0UL);
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2200              MOVS     r2,#0
000024  4619              MOV      r1,r3
000026  f7ffbffe          B.W      CLK_SetModuleClock
;;;65     }
;;;66     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x57c00006

                          AREA ||i.CLK_EnableDPDWKPin||, CODE, READONLY, ALIGN=1

                  CLK_EnableDPDWKPin PROC
;;;1106   
;;;1107   void CLK_EnableDPDWKPin(uint32_t u32TriggerType)
000000  b530              PUSH     {r4,r5,lr}
;;;1108   {
;;;1109       uint32_t u32Pin1, u32Pin2, u32Pin3, u32Pin4;
;;;1110   
;;;1111       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000002  f04f4180          MOV      r1,#0x40000000
000006  f8d121f4          LDR      r2,[r1,#0x1f4]
00000a  b2d2              UXTB     r2,r2
00000c  2a01              CMP      r2,#1
00000e  d122              BNE      |L7.86|
;;;1112       {
;;;1113   
;;;1114           u32Pin1 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN1_Msk);
000010  f0107f40          TST      r0,#0x3000000
;;;1115           u32Pin2 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN2_Msk);
000014  f0006440          AND      r4,r0,#0xc000000
;;;1116           u32Pin3 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN3_Msk);
000018  f0005340          AND      r3,r0,#0x30000000
;;;1117           u32Pin4 = ((u32TriggerType) & CLK_PMUCTL_WKPINEN4_Msk);
00001c  f0004240          AND      r2,r0,#0xc0000000
;;;1118   
;;;1119           if(u32Pin1)
000020  d007              BEQ      |L7.50|
;;;1120           {
;;;1121               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN1_Msk)) | u32TriggerType;
000022  f8d12290          LDR      r2,[r1,#0x290]
000026  f0227240          BIC      r2,r2,#0x3000000
                  |L7.42|
;;;1122           }
;;;1123           else if(u32Pin2)
;;;1124           {
;;;1125               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN2_Msk)) | u32TriggerType;
;;;1126           }
;;;1127           else if(u32Pin3)
;;;1128           {
;;;1129               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN3_Msk)) | u32TriggerType;
;;;1130           }
;;;1131           else if(u32Pin4)
;;;1132           {
;;;1133               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN4_Msk)) | u32TriggerType;
;;;1134           }
;;;1135           else
;;;1136           {
;;;1137               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
;;;1138           }
;;;1139       }
;;;1140       else
;;;1141       {
;;;1142           CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
00002a  4302              ORRS     r2,r2,r0
00002c  f8c12290          STR      r2,[r1,#0x290]
;;;1143       }
;;;1144   }
000030  bd30              POP      {r4,r5,pc}
                  |L7.50|
000032  b124              CBZ      r4,|L7.62|
000034  f8d12290          LDR      r2,[r1,#0x290]        ;1125
000038  f0226240          BIC      r2,r2,#0xc000000      ;1125
00003c  e7f5              B        |L7.42|
                  |L7.62|
00003e  b123              CBZ      r3,|L7.74|
000040  f8d12290          LDR      r2,[r1,#0x290]        ;1129
000044  f0225240          BIC      r2,r2,#0x30000000     ;1129
000048  e7ef              B        |L7.42|
                  |L7.74|
00004a  b122              CBZ      r2,|L7.86|
00004c  f8d12290          LDR      r2,[r1,#0x290]        ;1133
000050  f0224240          BIC      r2,r2,#0xc0000000     ;1133
000054  e7e9              B        |L7.42|
                  |L7.86|
000056  f8d12290          LDR      r2,[r1,#0x290]        ;1137
00005a  f4223240          BIC      r2,r2,#0x30000        ;1137
00005e  e7e4              B        |L7.42|
;;;1145   
                          ENDP


                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;686      */
;;;687    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;688    {
;;;689        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;690    
;;;691        u32tmpVal = (1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;692        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L8.24|
;;;693        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;694    
;;;695        *(volatile uint32_t *)u32tmpAddr |= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  430a              ORRS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;696    }
000016  4770              BX       lr
;;;697    
                          ENDP

                  |L8.24|
                          DCD      0x40000204

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;791      */
;;;792    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;793    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;794        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32PllClk;
;;;795        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR, u32MinNO, u32basFreq;
;;;796    
;;;797        /* Disable PLL first to avoid unstable when setting PLL */
;;;798        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;799    
;;;800        /* PLL source clock is from HXT */
;;;801        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;802        {
;;;803            /* Enable HXT clock */
;;;804            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;805    
;;;806            /* Wait for HXT clock ready */
;;;807            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;808    
;;;809            /* Select PLL source clock from HXT */
;;;810            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;811            u32PllSrcClk = __HXT;
;;;812    
;;;813            /* u32NR start from 2 */
;;;814            u32NR = 2UL;
;;;815        }
;;;816    
;;;817        /* PLL source clock is from HIRC */
;;;818        else
;;;819        {
;;;820            /* Enable HIRC clock */
;;;821            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  f04f4080          MOV      r0,#0x40000000
000010  4e48              LDR      r6,|L9.308|
000012  f8d01200          LDR      r1,[r0,#0x200]
000016  b1c4              CBZ      r4,|L9.74|
000018  f0410104          ORR      r1,r1,#4
00001c  f8c01200          STR      r1,[r0,#0x200]
;;;822    
;;;823            /* Wait for HIRC clock ready */
;;;824            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       CLK_WaitClockReady
;;;825    
;;;826            /* Select PLL source clock from HIRC */
;;;827            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000026  f44f2000          MOV      r0,#0x80000
                  |L9.42|
;;;828            u32PllSrcClk = __HIRC;
;;;829    
;;;830            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;831            u32NR = 4UL;
;;;832        }
;;;833    
;;;834        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq >= FREQ_50MHZ))
00002a  9000              STR      r0,[sp,#0]
00002c  4842              LDR      r0,|L9.312|
00002e  4943              LDR      r1,|L9.316|
000030  4428              ADD      r0,r0,r5
000032  46b3              MOV      r11,r6                ;828
000034  4288              CMP      r0,r1
000036  d86d              BHI      |L9.276|
;;;835        {
;;;836    
;;;837            /* Find best solution */
;;;838            u32Min = (uint32_t) - 1;
;;;839            u32MinNR = 0UL;
000038  f04f0900          MOV      r9,#0
00003c  f04f32ff          MOV      r2,#0xffffffff        ;838
;;;840            u32MinNF = 0UL;
000040  464f              MOV      r7,r9
;;;841            u32MinNO = 0UL;
000042  464e              MOV      r6,r9
;;;842            u32basFreq = u32PllFreq;
000044  46ae              MOV      lr,r5
;;;843    
;;;844            for(u32NO = 1UL; u32NO <= 4UL; u32NO++)
000046  2001              MOVS     r0,#1
000048  e015              B        |L9.118|
                  |L9.74|
00004a  f0410101          ORR      r1,r1,#1              ;804
00004e  f8c01200          STR      r1,[r0,#0x200]        ;804
000052  2001              MOVS     r0,#1                 ;807
000054  f7fffffe          BL       CLK_WaitClockReady
000058  2000              MOVS     r0,#0                 ;810
00005a  e7e6              B        |L9.42|
                  |L9.92|
;;;845            {
;;;846                /* Break when get good results */
;;;847                if (u32Min == 0UL)
00005c  b3f2              CBZ      r2,|L9.220|
;;;848                {
;;;849                    break;
;;;850                }
;;;851    
;;;852                if (u32NO != 3UL)
00005e  2803              CMP      r0,#3
000060  d039              BEQ      |L9.214|
;;;853                {
;;;854    
;;;855                    if(u32NO == 4UL)
000062  2804              CMP      r0,#4
000064  d002              BEQ      |L9.108|
;;;856                    {
;;;857                        u32PllFreq = u32basFreq << 2;
;;;858                    }
;;;859                    else if(u32NO == 2UL)
000066  2802              CMP      r0,#2
000068  d105              BNE      |L9.118|
00006a  e002              B        |L9.114|
                  |L9.108|
00006c  ea4f058e          LSL      r5,lr,#2              ;857
000070  e001              B        |L9.118|
                  |L9.114|
;;;860                    {
;;;861                        u32PllFreq = u32basFreq << 1;
000072  ea4f054e          LSL      r5,lr,#1
                  |L9.118|
;;;862                    }
;;;863                    else
;;;864                    {
;;;865                    }
;;;866    
;;;867                    for(u32NR = 2UL; u32NR <= 32UL; u32NR++)
000076  2302              MOVS     r3,#2
                  |L9.120|
;;;868                    {
;;;869                        /* Break when get good results */
;;;870                        if (u32Min == 0UL)
000078  b36a              CBZ      r2,|L9.214|
;;;871                        {
;;;872                            break;
;;;873                        }
;;;874    
;;;875                        u32Tmp = u32PllSrcClk / u32NR;
00007a  fbbbf1f3          UDIV     r1,r11,r3
;;;876                        if((u32Tmp >= 4000000UL) && (u32Tmp <= 8000000UL))
00007e  4c30              LDR      r4,|L9.320|
000080  f8dfc0bc          LDR      r12,|L9.320|
000084  440c              ADD      r4,r4,r1
000086  f1cc0c00          RSB      r12,r12,#0
00008a  4564              CMP      r4,r12
00008c  d820              BHI      |L9.208|
;;;877                        {
;;;878                            for(u32NF = 2UL; u32NF <= 513UL; u32NF++)
00008e  2402              MOVS     r4,#2
;;;879                            {
;;;880                                /* u32Tmp2 is shifted 2 bits to avoid overflow */
;;;881                                u32Tmp2 = (((u32Tmp * 2UL) >> 2) * u32NF);
000090  f3c10a5d          UBFX     r10,r1,#1,#30
                  |L9.148|
;;;882    
;;;883                                if((u32Tmp2 >= FREQ_50MHZ) && (u32Tmp2 <= FREQ_125MHZ))
000094  f8dfc0a0          LDR      r12,|L9.312|
000098  fb0af104          MUL      r1,r10,r4             ;881
00009c  eb01080c          ADD      r8,r1,r12
0000a0  f8dfc0a0          LDR      r12,|L9.324|
0000a4  45e0              CMP      r8,r12
0000a6  d80e              BHI      |L9.198|
;;;884                                {
;;;885                                    u32Tmp3 = (u32Tmp2 > (u32PllFreq>>2)) ? u32Tmp2 - (u32PllFreq>>2) : (u32PllFreq>>2) - u32Tmp2;
0000a8  ebb10f95          CMP      r1,r5,LSR #2
0000ac  d902              BLS      |L9.180|
0000ae  eba10195          SUB      r1,r1,r5,LSR #2
0000b2  e001              B        |L9.184|
                  |L9.180|
0000b4  ebc10195          RSB      r1,r1,r5,LSR #2
                  |L9.184|
;;;886                                    if(u32Tmp3 < u32Min)
0000b8  4291              CMP      r1,r2
0000ba  d204              BCS      |L9.198|
;;;887                                    {
;;;888                                        u32Min = u32Tmp3;
0000bc  000a              MOVS     r2,r1
;;;889                                        u32MinNR = u32NR;
0000be  4699              MOV      r9,r3
;;;890                                        u32MinNF = u32NF;
0000c0  4627              MOV      r7,r4
;;;891                                        u32MinNO = u32NO;
0000c2  4606              MOV      r6,r0
;;;892    
;;;893                                        /* Break when get good results */
;;;894                                        if(u32Min == 0UL)
0000c4  d004              BEQ      |L9.208|
                  |L9.198|
0000c6  f2402101          MOV      r1,#0x201             ;878
0000ca  1c64              ADDS     r4,r4,#1              ;878
0000cc  428c              CMP      r4,r1                 ;878
0000ce  d9e1              BLS      |L9.148|
                  |L9.208|
0000d0  1c5b              ADDS     r3,r3,#1              ;878
0000d2  2b20              CMP      r3,#0x20              ;867
0000d4  d9d0              BLS      |L9.120|
                  |L9.214|
0000d6  1c40              ADDS     r0,r0,#1              ;867
0000d8  2804              CMP      r0,#4                 ;844
0000da  e000              B        |L9.222|
                  |L9.220|
0000dc  e000              B        |L9.224|
                  |L9.222|
0000de  d9bd              BLS      |L9.92|
                  |L9.224|
;;;895                                        {
;;;896                                            break;
;;;897                                        }
;;;898                                    }
;;;899                                }
;;;900                            }
;;;901                        }
;;;902                    }
;;;903                }
;;;904            }
;;;905    
;;;906            /* Enable and apply new PLL setting. */
;;;907            CLK->PLLCTL = u32CLK_SRC | ((u32MinNO - 1UL) << 14) | ((u32MinNR - 1UL) << 9) | (u32MinNF - 2UL);
0000e0  4819              LDR      r0,|L9.328|
0000e2  9900              LDR      r1,[sp,#0]
0000e4  eb003086          ADD      r0,r0,r6,LSL #14
0000e8  4a18              LDR      r2,|L9.332|
0000ea  4308              ORRS     r0,r0,r1
0000ec  eb022149          ADD      r1,r2,r9,LSL #9
0000f0  4308              ORRS     r0,r0,r1
0000f2  1eb9              SUBS     r1,r7,#2
0000f4  4308              ORRS     r0,r0,r1
0000f6  f04f4180          MOV      r1,#0x40000000
0000fa  f8c10240          STR      r0,[r1,#0x240]
;;;908    
;;;909            /* Wait for PLL clock stable */
;;;910            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000fe  2004              MOVS     r0,#4
000100  f7fffffe          BL       CLK_WaitClockReady
;;;911    
;;;912            /* Actual PLL output clock frequency */
;;;913            u32PllClk = u32PllSrcClk / (u32MinNO * (u32MinNR)) * (u32MinNF) * 2UL;
000104  fb06f609          MUL      r6,r6,r9
000108  fbbbf0f6          UDIV     r0,r11,r6
00010c  4378              MULS     r0,r7,r0
00010e  0040              LSLS     r0,r0,#1
;;;914        }
;;;915        else
;;;916        {
;;;917            /* Wrong frequency request. Just return default setting. */
;;;918            /* Apply default PLL setting and return */
;;;919            if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;920            {
;;;921                CLK->PLLCTL = CLK_PLLCTL_192MHz_HXT;
;;;922            }
;;;923            else
;;;924            {
;;;925                CLK->PLLCTL = CLK_PLLCTL_192MHz_HIRC;
;;;926            }
;;;927    
;;;928            /* Wait for PLL clock stable */
;;;929            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;930    
;;;931            /* Actual PLL output clock frequency */
;;;932            u32PllClk = CLK_GetPLLClockFreq();
;;;933        }
;;;934    
;;;935        return u32PllClk;
;;;936    }
000110  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.276|
000114  b15c              CBZ      r4,|L9.302|
000116  490e              LDR      r1,|L9.336|
                  |L9.280|
000118  f04f4080          MOV      r0,#0x40000000        ;925
00011c  f8c01240          STR      r1,[r0,#0x240]        ;925
000120  2004              MOVS     r0,#4                 ;929
000122  f7fffffe          BL       CLK_WaitClockReady
000126  e8bd4ff8          POP      {r3-r11,lr}           ;932
00012a  f7ffbffe          B.W      CLK_GetPLLClockFreq
                  |L9.302|
00012e  f244211e          MOV      r1,#0x421e            ;921
000132  e7f1              B        |L9.280|
;;;937    
                          ENDP

                  |L9.308|
                          DCD      0x00b71b00
                  |L9.312|
                          DCD      0xfd050f80
                  |L9.316|
                          DCD      0x1ad27480
                  |L9.320|
                          DCD      0xffc2f700
                  |L9.324|
                          DCD      0x047868c0
                  |L9.328|
                          DCD      0xffffc000
                  |L9.332|
                          DCD      0xfffffe00
                  |L9.336|
                          DCD      0x0008421e

                          AREA ||i.CLK_EnableSPDWKPin||, CODE, READONLY, ALIGN=2

                  CLK_EnableSPDWKPin PROC
;;;1175    */
;;;1176   void CLK_EnableSPDWKPin(uint32_t u32Port, uint32_t u32Pin, uint32_t u32TriggerType, uint32_t u32DebounceEn)
000000  b530              PUSH     {r4,r5,lr}
;;;1177   {
;;;1178       uint32_t u32tmpAddr = 0UL;
;;;1179       uint32_t u32tmpVal = 0UL;
;;;1180   
;;;1181       /* GPx Stand-by Power-down Wake-up Pin Select */
;;;1182       u32tmpAddr = (uint32_t)&CLK->PASWKCTL;
000002  4c07              LDR      r4,|L10.32|
;;;1183       u32tmpAddr += (0x4UL * u32Port);
000004  eb040080          ADD      r0,r4,r0,LSL #2
;;;1184   
;;;1185       u32tmpVal = inpw((uint32_t *)u32tmpAddr);
000008  6804              LDR      r4,[r0,#0]
;;;1186       u32tmpVal = (u32tmpVal & ~(CLK_PASWKCTL_WKPSEL_Msk | CLK_PASWKCTL_PRWKEN_Msk | CLK_PASWKCTL_PFWKEN_Msk | CLK_PASWKCTL_DBEN_Msk | CLK_PASWKCTL_WKEN_Msk)) |
00000a  f24015f7          MOV      r5,#0x1f7
00000e  43ac              BICS     r4,r4,r5
000010  ea441101          ORR      r1,r4,r1,LSL #4
000014  4311              ORRS     r1,r1,r2
000016  4319              ORRS     r1,r1,r3
000018  f0410101          ORR      r1,r1,#1
;;;1187                   (u32Pin << CLK_PASWKCTL_WKPSEL_Pos) | u32TriggerType | u32DebounceEn | CLK_SPDWKPIN_ENABLE;
;;;1188       outpw((uint32_t *)u32tmpAddr, u32tmpVal);
00001c  6001              STR      r1,[r0,#0]
;;;1189   }
00001e  bd30              POP      {r4,r5,pc}
;;;1190   
                          ENDP

                  |L10.32|
                          DCD      0x400002a0

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_EnableSysTick PROC
;;;998      */
;;;999    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b530              PUSH     {r4,r5,lr}
;;;1000   {
;;;1001       /* Set System Tick counter disabled */
;;;1002       SysTick->CTRL = 0UL;
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2500              MOVS     r5,#0
000008  6115              STR      r5,[r2,#0x10]
;;;1003   
;;;1004       /* Set System Tick clock source */
;;;1005       if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )
00000a  2804              CMP      r0,#4
00000c  d00f              BEQ      |L11.46|
;;;1006       {
;;;1007           SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;1008       }
;;;1009       else
;;;1010       {
;;;1011           CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000e  f04f4380          MOV      r3,#0x40000000
000012  f8d34210          LDR      r4,[r3,#0x210]
000016  f0240438          BIC      r4,r4,#0x38
00001a  4304              ORRS     r4,r4,r0
00001c  f8c34210          STR      r4,[r3,#0x210]
                  |L11.32|
;;;1012       }
;;;1013   
;;;1014       /* Set System Tick reload value */
;;;1015       SysTick->LOAD = u32Count;
000020  6151              STR      r1,[r2,#0x14]
;;;1016   
;;;1017       /* Clear System Tick current value and counter flag */
;;;1018       SysTick->VAL = 0UL;
000022  6195              STR      r5,[r2,#0x18]
;;;1019   
;;;1020       /* Set System Tick interrupt enabled and counter enabled */
;;;1021       SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
;;;1022   }
00002c  bd30              POP      {r4,r5,pc}
                  |L11.46|
00002e  6910              LDR      r0,[r2,#0x10]         ;1007
000030  f0400004          ORR      r0,r0,#4              ;1007
000034  6110              STR      r0,[r2,#0x10]         ;1007
000036  e7f3              B        |L11.32|
;;;1023   
                          ENDP


                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_EnableXtalRC PROC
;;;593      */
;;;594    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;595    {
;;;596        CLK->PWRCTL |= u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4302              ORRS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;597    }
00000e  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;258      */
;;;259    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;260    {
;;;261        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;262        return SystemCoreClock;
000006  4801              LDR      r0,|L13.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;263    }
00000a  bd10              POP      {r4,pc}
;;;264    
                          ENDP

                  |L13.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;245      */
;;;246    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;247    {
;;;248        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;249        return SystemCoreClock;
000006  4801              LDR      r0,|L14.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;250    }
00000a  bd10              POP      {r4,pc}
;;;251    
                          ENDP

                  |L14.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;121      */
;;;122    uint32_t CLK_GetHXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;123    {
;;;124        uint32_t u32Freq;
;;;125    
;;;126        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  07c0              LSLS     r0,r0,#31
00000a  d000              BEQ      |L15.14|
;;;127        {
;;;128            u32Freq = __HXT;
00000c  4800              LDR      r0,|L15.16|
                  |L15.14|
;;;129        }
;;;130        else
;;;131        {
;;;132            u32Freq = 0UL;
;;;133        }
;;;134    
;;;135        return u32Freq;
;;;136    }
00000e  4770              BX       lr
;;;137    
                          ENDP

                  |L15.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=1

                  CLK_GetLXTFreq PROC
;;;144      */
;;;145    uint32_t CLK_GetLXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;146    {
;;;147        uint32_t u32Freq;
;;;148        if((CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk) == CLK_PWRCTL_LXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  0780              LSLS     r0,r0,#30
00000a  d502              BPL      |L16.18|
;;;149        {
;;;150            u32Freq = __LXT;
00000c  f44f4000          MOV      r0,#0x8000
;;;151        }
;;;152        else
;;;153        {
;;;154            u32Freq = 0UL;
;;;155        }
;;;156    
;;;157        return u32Freq;
;;;158    }
000010  4770              BX       lr
                  |L16.18|
000012  2000              MOVS     r0,#0                 ;154
000014  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.CLK_GetModuleClockDivider||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockDivider PROC
;;;1331     */
;;;1332   uint32_t CLK_GetModuleClockDivider(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1333   {
;;;1334       uint32_t u32div = 0;
;;;1335       uint32_t u32DivTbl[4] = {0x0, 0x4, 0xc, 0x10};
000002  4914              LDR      r1,|L17.84|
;;;1336   
;;;1337       if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000004  f4103f7f          TST      r0,#0x3fc00
000008  c91e              LDM      r1,{r1-r4}            ;1335
00000a  e88d001e          STM      sp,{r1-r4}            ;1335
00000e  d01f              BEQ      |L17.80|
;;;1338       {
;;;1339           /* Get clock divider control register address */
;;;1340           u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000010  f3c04281          UBFX     r2,r0,#18,#2
000014  f85d1022          LDR      r1,[sp,r2,LSL #2]
000018  4a0f              LDR      r2,|L17.88|
00001a  4411              ADD      r1,r1,r2
;;;1341           if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
00001c  0652              LSLS     r2,r2,#25
00001e  f8d221f4          LDR      r2,[r2,#0x1f4]
000022  b2d2              UXTB     r2,r2
000024  2a01              CMP      r2,#1
000026  d108              BNE      |L17.58|
;;;1342           {
;;;1343               if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
000028  43c2              MVNS     r2,r0
;;;1344                   u32div = (uint32_t)&CLK->CLKDIV2;
00002a  4b0c              LDR      r3,|L17.92|
00002c  06d2              LSLS     r2,r2,#27             ;1343
00002e  d003              BEQ      |L17.56|
;;;1345               else if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
000030  f000021f          AND      r2,r0,#0x1f
000034  2a1d              CMP      r2,#0x1d
000036  d100              BNE      |L17.58|
                  |L17.56|
;;;1346                   u32div = (uint32_t)&CLK->CLKDIV2;
000038  4619              MOV      r1,r3
                  |L17.58|
;;;1347           }
;;;1348           /* Get clock divider number setting */
;;;1349           return ((M32(u32div) & (MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx))) >> MODULE_CLKDIV_Pos(u32ModuleIdx));
00003a  6809              LDR      r1,[r1,#0]
00003c  f3c02287          UBFX     r2,r0,#10,#8
000040  f3c01044          UBFX     r0,r0,#5,#5
000044  4082              LSLS     r2,r2,r0
000046  4011              ANDS     r1,r1,r2
000048  fa21f000          LSR      r0,r1,r0
                  |L17.76|
;;;1350       }
;;;1351       else
;;;1352           return 0;
;;;1353   }
00004c  b004              ADD      sp,sp,#0x10
00004e  bd10              POP      {r4,pc}
                  |L17.80|
000050  2000              MOVS     r0,#0                 ;1352
000052  e7fb              B        |L17.76|
;;;1354   
                          ENDP

                  |L17.84|
                          DCD      ||.constdata||+0x10
                  |L17.88|
                          DCD      0x40000220
                  |L17.92|
                          DCD      0x40000228

                          AREA ||i.CLK_GetModuleClockSource||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockSource PROC
;;;1282     */
;;;1283   uint32_t CLK_GetModuleClockSource(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1284   {
;;;1285       uint32_t u32sel = 0;
;;;1286       uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};
000002  491d              LDR      r1,|L18.120|
000004  c91e              LDM      r1,{r1-r4}
000006  e88d001e          STM      sp,{r1-r4}
;;;1287   
;;;1288       /* Get clock source selection setting */
;;;1289       if(u32ModuleIdx == EPWM0_MODULE)
00000a  4a1c              LDR      r2,|L18.124|
;;;1290           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk) >> CLK_CLKSEL2_EPWM0SEL_Pos);
00000c  0691              LSLS     r1,r2,#26
00000e  4290              CMP      r0,r2                 ;1289
000010  d105              BNE      |L18.30|
000012  f8d10218          LDR      r0,[r1,#0x218]
000016  f0000001          AND      r0,r0,#1
                  |L18.26|
;;;1291       else if(u32ModuleIdx == EPWM1_MODULE)
;;;1292           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk) >> CLK_CLKSEL2_EPWM1SEL_Pos);
;;;1293       else if(u32ModuleIdx == BPWM0_MODULE)
;;;1294           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk) >> CLK_CLKSEL2_BPWM0SEL_Pos);
;;;1295       else if(u32ModuleIdx == BPWM1_MODULE)
;;;1296           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk) >> CLK_CLKSEL2_BPWM1SEL_Pos);
;;;1297       else if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
;;;1298       {
;;;1299           /* Get clock select control register address */
;;;1300           u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
;;;1301           /* Get clock source selection setting */
;;;1302           return ((M32(u32sel) & (MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx))) >> MODULE_CLKSEL_Pos(u32ModuleIdx));
;;;1303       }
;;;1304       else
;;;1305           return 0;
;;;1306   }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  4a18              LDR      r2,|L18.128|
000020  4290              CMP      r0,r2                 ;1291
000022  d104              BNE      |L18.46|
000024  f8d10218          LDR      r0,[r1,#0x218]        ;1292
000028  f3c00040          UBFX     r0,r0,#1,#1           ;1292
00002c  e7f5              B        |L18.26|
                  |L18.46|
00002e  4a15              LDR      r2,|L18.132|
000030  4290              CMP      r0,r2                 ;1293
000032  d104              BNE      |L18.62|
000034  f8d10218          LDR      r0,[r1,#0x218]        ;1294
000038  f3c02000          UBFX     r0,r0,#8,#1           ;1294
00003c  e7ed              B        |L18.26|
                  |L18.62|
00003e  4a12              LDR      r2,|L18.136|
000040  4290              CMP      r0,r2                 ;1295
000042  d104              BNE      |L18.78|
000044  f8d10218          LDR      r0,[r1,#0x218]        ;1296
000048  f3c02040          UBFX     r0,r0,#9,#1           ;1296
00004c  e7e5              B        |L18.26|
                  |L18.78|
00004e  0e41              LSRS     r1,r0,#25             ;1297
000050  0749              LSLS     r1,r1,#29             ;1297
000052  d00e              BEQ      |L18.114|
000054  f3c07201          UBFX     r2,r0,#28,#2          ;1300
000058  f85d1022          LDR      r1,[sp,r2,LSL #2]     ;1300
00005c  4a0b              LDR      r2,|L18.140|
00005e  5889              LDR      r1,[r1,r2]            ;1302
000060  f3c06242          UBFX     r2,r0,#25,#3          ;1302
000064  f3c05004          UBFX     r0,r0,#20,#5          ;1302
000068  4082              LSLS     r2,r2,r0              ;1302
00006a  4011              ANDS     r1,r1,r2              ;1302
00006c  fa21f000          LSR      r0,r1,r0              ;1302
000070  e7d3              B        |L18.26|
                  |L18.114|
000072  2000              MOVS     r0,#0                 ;1305
000074  e7d1              B        |L18.26|
;;;1307   
                          ENDP

000076  0000              DCW      0x0000
                  |L18.120|
                          DCD      ||.constdata||
                  |L18.124|
                          DCD      0xa2000010
                  |L18.128|
                          DCD      0xa2100011
                  |L18.132|
                          DCD      0xa2800012
                  |L18.136|
                          DCD      0xa2900013
                  |L18.140|
                          DCD      0x40000210

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;165      */
;;;166    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168        uint32_t u32Freq;
;;;169        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;170    
;;;171        if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  0742              LSLS     r2,r0,#29
;;;172        {
;;;173            u32Freq = SystemCoreClock;
000010  4813              LDR      r0,|L19.96|
000012  d017              BEQ      |L19.68|
;;;174        }
;;;175        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV2)
000014  f8d12234          LDR      r2,[r1,#0x234]
000018  f0020207          AND      r2,r2,#7
00001c  2a01              CMP      r2,#1
00001e  d013              BEQ      |L19.72|
;;;176        {
;;;177            u32Freq = SystemCoreClock / 2UL;
;;;178        }
;;;179        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV4)
000020  f8d12234          LDR      r2,[r1,#0x234]
000024  f0020207          AND      r2,r2,#7
000028  2a02              CMP      r2,#2
00002a  d010              BEQ      |L19.78|
;;;180        {
;;;181            u32Freq = SystemCoreClock / 4UL;
;;;182        }
;;;183        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV8)
00002c  f8d12234          LDR      r2,[r1,#0x234]
000030  f0020207          AND      r2,r2,#7
000034  2a03              CMP      r2,#3
000036  d00d              BEQ      |L19.84|
;;;184        {
;;;185            u32Freq = SystemCoreClock / 8UL;
;;;186        }
;;;187        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV16)
000038  f8d11234          LDR      r1,[r1,#0x234]
00003c  f0010107          AND      r1,r1,#7
000040  2904              CMP      r1,#4
000042  d00a              BEQ      |L19.90|
                  |L19.68|
000044  6800              LDR      r0,[r0,#0]            ;173  ; SystemCoreClock
;;;188        {
;;;189            u32Freq = SystemCoreClock / 16UL;
;;;190        }
;;;191        else
;;;192        {
;;;193            u32Freq = SystemCoreClock;
;;;194        }
;;;195    
;;;196        return u32Freq;
;;;197    }
000046  bd10              POP      {r4,pc}
                  |L19.72|
000048  6800              LDR      r0,[r0,#0]            ;177  ; SystemCoreClock
00004a  0840              LSRS     r0,r0,#1              ;177
00004c  bd10              POP      {r4,pc}
                  |L19.78|
00004e  6800              LDR      r0,[r0,#0]            ;181  ; SystemCoreClock
000050  0880              LSRS     r0,r0,#2              ;181
000052  bd10              POP      {r4,pc}
                  |L19.84|
000054  6800              LDR      r0,[r0,#0]            ;185  ; SystemCoreClock
000056  08c0              LSRS     r0,r0,#3              ;185
000058  bd10              POP      {r4,pc}
                  |L19.90|
00005a  6800              LDR      r0,[r0,#0]            ;189  ; SystemCoreClock
00005c  0900              LSRS     r0,r0,#4              ;189
00005e  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L19.96|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;205      */
;;;206    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;207    {
;;;208        uint32_t u32Freq;
;;;209        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;210    
;;;211        if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  f0100f70          TST      r0,#0x70
;;;212        {
;;;213            u32Freq = SystemCoreClock;
000012  4814              LDR      r0,|L20.100|
000014  d017              BEQ      |L20.70|
;;;214        }
;;;215        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV2)
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f3c21202          UBFX     r2,r2,#4,#3
00001e  2a01              CMP      r2,#1
000020  d013              BEQ      |L20.74|
;;;216        {
;;;217            u32Freq = SystemCoreClock / 2UL;
;;;218        }
;;;219        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV4)
000022  f8d12234          LDR      r2,[r1,#0x234]
000026  f3c21202          UBFX     r2,r2,#4,#3
00002a  2a02              CMP      r2,#2
00002c  d010              BEQ      |L20.80|
;;;220        {
;;;221            u32Freq = SystemCoreClock / 4UL;
;;;222        }
;;;223        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV8)
00002e  f8d12234          LDR      r2,[r1,#0x234]
000032  f3c21202          UBFX     r2,r2,#4,#3
000036  2a03              CMP      r2,#3
000038  d00d              BEQ      |L20.86|
;;;224        {
;;;225            u32Freq = SystemCoreClock / 8UL;
;;;226        }
;;;227        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV16)
00003a  f8d11234          LDR      r1,[r1,#0x234]
00003e  f3c11102          UBFX     r1,r1,#4,#3
000042  2904              CMP      r1,#4
000044  d00a              BEQ      |L20.92|
                  |L20.70|
000046  6800              LDR      r0,[r0,#0]            ;213  ; SystemCoreClock
;;;228        {
;;;229            u32Freq = SystemCoreClock / 16UL;
;;;230        }
;;;231        else
;;;232        {
;;;233            u32Freq = SystemCoreClock;
;;;234        }
;;;235    
;;;236        return u32Freq;
;;;237    }
000048  bd10              POP      {r4,pc}
                  |L20.74|
00004a  6800              LDR      r0,[r0,#0]            ;217  ; SystemCoreClock
00004c  0840              LSRS     r0,r0,#1              ;217
00004e  bd10              POP      {r4,pc}
                  |L20.80|
000050  6800              LDR      r0,[r0,#0]            ;221  ; SystemCoreClock
000052  0880              LSRS     r0,r0,#2              ;221
000054  bd10              POP      {r4,pc}
                  |L20.86|
000056  6800              LDR      r0,[r0,#0]            ;225  ; SystemCoreClock
000058  08c0              LSRS     r0,r0,#3              ;225
00005a  bd10              POP      {r4,pc}
                  |L20.92|
00005c  6800              LDR      r0,[r0,#0]            ;229  ; SystemCoreClock
00005e  0900              LSRS     r0,r0,#4              ;229
000060  bd10              POP      {r4,pc}
;;;238    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;1196     */
;;;1197   uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;1198   {
;;;1199       uint32_t u32PllFreq = 0UL, u32PllReg;
;;;1200       uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;1201       uint8_t au8NoTbl[4] = {1U, 2U, 2U, 4U};
000002  a110              ADR      r1,|L21.68|
000004  2000              MOVS     r0,#0                 ;1199
000006  6809              LDR      r1,[r1,#0]
;;;1202   
;;;1203       u32PllReg = CLK->PLLCTL;
000008  9100              STR      r1,[sp,#0]
00000a  f04f4180          MOV      r1,#0x40000000
00000e  f8d11240          LDR      r1,[r1,#0x240]
;;;1204   
;;;1205       if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000012  f4112fa0          TST      r1,#0x50000
000016  d113              BNE      |L21.64|
;;;1206       {
;;;1207           u32PllFreq = 0UL;           /* PLL is in power down mode or fix low */
;;;1208       }
;;;1209       else if((u32PllReg & CLK_PLLCTL_BP_Msk) == CLK_PLLCTL_BP_Msk)
;;;1210       {
;;;1211           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1212           {
;;;1213               u32FIN = __HIRC;    /* PLL source clock from HIRC */
000018  480b              LDR      r0,|L21.72|
00001a  038a              LSLS     r2,r1,#14             ;1209
00001c  d410              BMI      |L21.64|
;;;1214           }
;;;1215           else
;;;1216           {
;;;1217               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1218           }
;;;1219   
;;;1220           u32PllFreq = u32FIN;
;;;1221       }
;;;1222       else
;;;1223       {
;;;1224           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1225           {
;;;1226               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1227           }
;;;1228           else
;;;1229           {
;;;1230               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1231           }
;;;1232           /* PLL is output enabled in normal work mode */
;;;1233           u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;1234           u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2UL;
00001e  f3c10008          UBFX     r0,r1,#0,#9
000022  f3c13281          UBFX     r2,r1,#14,#2          ;1233
;;;1235           u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 1UL;
;;;1236   
;;;1237           /* u32FIN is shifted 2 bits to avoid overflow */
;;;1238           u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2) * 2UL;
000026  4b09              LDR      r3,|L21.76|
000028  1c80              ADDS     r0,r0,#2
00002a  f81d2002          LDRB     r2,[sp,r2]            ;1233
00002e  f3c12144          UBFX     r1,r1,#9,#5           ;1235
000032  4358              MULS     r0,r3,r0
000034  1c49              ADDS     r1,r1,#1
000036  fb11f102          SMULBB   r1,r1,r2
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  00c0              LSLS     r0,r0,#3
                  |L21.64|
;;;1239       }
;;;1240   
;;;1241       return u32PllFreq;
;;;1242   }
000040  bd08              POP      {r3,pc}
;;;1243   
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
000044  01020204          DCB      1,2,2,4
                  |L21.72|
                          DCD      0x00b71b00
                  |L21.76|
                          DCD      0x002dc6c0

                          AREA ||i.CLK_GetPMUWKSrc||, CODE, READONLY, ALIGN=1

                  CLK_GetPMUWKSrc PROC
;;;1154   
;;;1155   uint32_t CLK_GetPMUWKSrc(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;1156   {
;;;1157       return (CLK->PMUSTS);
000004  f8d00294          LDR      r0,[r0,#0x294]
;;;1158   }
000008  4770              BX       lr
;;;1159   
                          ENDP


                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;103      */
;;;104    void CLK_Idle(void)
000000  4806              LDR      r0,|L23.28|
;;;105    {
;;;106        /* Set the processor uses sleep as its low power mode */
;;;107        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;108    
;;;109        /* Set chip in idle mode because of WFI command */
;;;110        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;111    
;;;112        /* Chip enter idle mode after CPU run WFI instruction */
;;;113        __WFI();
000018  bf30              WFI      
;;;114    }
00001a  4770              BX       lr
;;;115    
                          ENDP

                  |L23.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
000000  480a              LDR      r0,|L24.44|
;;;75     {
;;;76         uint32_t u32HIRCTRIMCTL;
;;;77     
;;;78         /* Set the processor uses deep sleep as its low power mode */
;;;79         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;80     
;;;81         /* Set system Power-down enabled */
;;;82         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0410180          ORR      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;83     
;;;84         /* Store HIRC control register */
;;;85         u32HIRCTRIMCTL = SYS->IRCTCTL;
000018  f8501ff0          LDR      r1,[r0,#0xf0]!
;;;86     
;;;87         /* Disable HIRC auto trim */
;;;88         SYS->IRCTCTL &= (~SYS_IRCTCTL_FREQSEL_Msk);
00001c  6802              LDR      r2,[r0,#0]
00001e  f0220203          BIC      r2,r2,#3
000022  6002              STR      r2,[r0,#0]
;;;89     
;;;90         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;91         __WFI();
000024  bf30              WFI      
;;;92     
;;;93         /* Restore HIRC control register */
;;;94         SYS->IRCTCTL = u32HIRCTRIMCTL;
000026  6001              STR      r1,[r0,#0]
;;;95     }
000028  4770              BX       lr
;;;96     
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      0xe000ed10

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;272      */
;;;273    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
;;;275        uint32_t u32HIRCSTB;
;;;276    
;;;277        /* Read HIRC clock source stable flag */
;;;278        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  f04f4480          MOV      r4,#0x40000000
000006  4606              MOV      r6,r0                 ;274
000008  f8d40250          LDR      r0,[r4,#0x250]
00000c  f0000510          AND      r5,r0,#0x10
;;;279    
;;;280        /* The range of u32Hclk is running up to 192 MHz */
;;;281        if(u32Hclk > FREQ_192MHZ)
000010  481b              LDR      r0,|L25.128|
000012  4286              CMP      r6,r0
000014  d900              BLS      |L25.24|
;;;282        {
;;;283            u32Hclk = FREQ_192MHZ;
000016  4606              MOV      r6,r0
                  |L25.24|
;;;284        }
;;;285    
;;;286        /* Switch HCLK clock source to HIRC clock for safe */
;;;287        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000018  f8d40200          LDR      r0,[r4,#0x200]
00001c  f0400004          ORR      r0,r0,#4
000020  f8c40200          STR      r0,[r4,#0x200]
;;;288        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000024  2010              MOVS     r0,#0x10
000026  f5047400          ADD      r4,r4,#0x200
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;289        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
00002e  6920              LDR      r0,[r4,#0x10]
000030  f0400007          ORR      r0,r0,#7
000034  6120              STR      r0,[r4,#0x10]
;;;290        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f020000f          BIC      r0,r0,#0xf
00003c  6220              STR      r0,[r4,#0x20]
;;;291    
;;;292        /* Configure PLL setting if HXT clock is enabled */
;;;293        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
00003e  6820              LDR      r0,[r4,#0]
000040  f5a47400          SUB      r4,r4,#0x200
000044  07c0              LSLS     r0,r0,#31
;;;294        {
;;;295            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, u32Hclk);
;;;296        }
;;;297        /* Configure PLL setting if HXT clock is not enabled */
;;;298        else
;;;299        {
;;;300            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, u32Hclk);
000046  4631              MOV      r1,r6
000048  d004              BEQ      |L25.84|
00004a  2000              MOVS     r0,#0                 ;295
00004c  f7fffffe          BL       CLK_EnablePLL
000050  4606              MOV      r6,r0                 ;295
000052  e008              B        |L25.102|
                  |L25.84|
000054  f44f2000          MOV      r0,#0x80000
000058  f7fffffe          BL       CLK_EnablePLL
00005c  4606              MOV      r6,r0
;;;301    
;;;302            /* Read HIRC clock source stable flag */
;;;303            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00005e  f8d40250          LDR      r0,[r4,#0x250]
000062  f0000510          AND      r5,r0,#0x10
                  |L25.102|
;;;304        }
;;;305    
;;;306        /* Select HCLK clock source to PLL,
;;;307           and update system core clock
;;;308        */
;;;309        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1UL));
000066  2100              MOVS     r1,#0
000068  2002              MOVS     r0,#2
00006a  f7fffffe          BL       CLK_SetHCLK
;;;310    
;;;311        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;312        if(u32HIRCSTB == 0UL)
00006e  b92d              CBNZ     r5,|L25.124|
;;;313        {
;;;314            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000070  f8d40200          LDR      r0,[r4,#0x200]
000074  f0200004          BIC      r0,r0,#4
000078  f8c40200          STR      r0,[r4,#0x200]
                  |L25.124|
;;;315        }
;;;316    
;;;317        /* Return actually HCLK frequency is PLL frequency divide 1 */
;;;318        return u32Hclk;
00007c  4630              MOV      r0,r6
;;;319    }
00007e  bd70              POP      {r4-r6,pc}
;;;320    
                          ENDP

                  |L25.128|
                          DCD      0x0b71b000

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=1

                  CLK_SetHCLK PROC
;;;334      */
;;;335    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;336    {
;;;337        uint32_t u32HIRCSTB;
;;;338    
;;;339        /* Read HIRC clock source stable flag */
;;;340        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  f04f4480          MOV      r4,#0x40000000
000008  4607              MOV      r7,r0                 ;336
00000a  f8d40250          LDR      r0,[r4,#0x250]
00000e  460e              MOV      r6,r1                 ;336
000010  f0000510          AND      r5,r0,#0x10
;;;341    
;;;342        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;343        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f0400004          ORR      r0,r0,#4
00001c  f8c40200          STR      r0,[r4,#0x200]
;;;344        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f5047400          ADD      r4,r4,#0x200
000026  f7fffffe          BL       CLK_WaitClockReady
;;;345        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f0400007          ORR      r0,r0,#7
000030  6120              STR      r0,[r4,#0x10]
;;;346    
;;;347        /* Apply new Divider */
;;;348        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000032  6a20              LDR      r0,[r4,#0x20]
000034  f020000f          BIC      r0,r0,#0xf
000038  4330              ORRS     r0,r0,r6
00003a  6220              STR      r0,[r4,#0x20]
;;;349    
;;;350        /* Switch HCLK to new HCLK source */
;;;351        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f0200007          BIC      r0,r0,#7
000042  4338              ORRS     r0,r0,r7
000044  6120              STR      r0,[r4,#0x10]
000046  f5a47400          SUB      r4,r4,#0x200
;;;352    
;;;353        /* Update System Core Clock */
;;;354        SystemCoreClockUpdate();
00004a  f7fffffe          BL       SystemCoreClockUpdate
;;;355    
;;;356        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;357        if(u32HIRCSTB == 0UL)
00004e  2d00              CMP      r5,#0
000050  d105              BNE      |L26.94|
;;;358        {
;;;359            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000052  f8d40200          LDR      r0,[r4,#0x200]
000056  f0200004          BIC      r0,r0,#4
00005a  f8c40200          STR      r0,[r4,#0x200]
                  |L26.94|
;;;360        }
;;;361    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;362    
                          ENDP


                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;504      */
;;;505    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;506    {
;;;507        uint32_t u32sel = 0U, u32div = 0U;
;;;508    
;;;509        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  f4103f7f          TST      r0,#0x3fc00
000006  d02e              BEQ      |L27.102|
;;;510        {
;;;511            /* Get clock divider control register address */
;;;512            if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000008  f04f4380          MOV      r3,#0x40000000
00000c  f8d331f4          LDR      r3,[r3,#0x1f4]
;;;513            {
;;;514                if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
;;;515                {
;;;516                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;517                }
;;;518                else if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
;;;519                {
;;;520                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;521                }
;;;522                else if (MODULE_CLKDIV(u32ModuleIdx) == 2U)
;;;523                {
;;;524                    u32div = (uint32_t)&CLK->CLKDIV3;
000010  f8dfc078          LDR      r12,|L27.140|
000014  b2df              UXTB     r7,r3                 ;512
;;;525                }
;;;526                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
;;;527                {
;;;528                    u32div = (uint32_t)&CLK->CLKDIV4;
;;;529                }
;;;530                else
;;;531                {
;;;532                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
000016  4b1d              LDR      r3,|L27.140|
000018  f3c04481          UBFX     r4,r0,#18,#2          ;514
00001c  3b0c              SUBS     r3,r3,#0xc
00001e  ea6f4590          MVN      r5,r0,LSR #18         ;526
000022  f10c0604          ADD      r6,r12,#4             ;528
000026  eb030384          ADD      r3,r3,r4,LSL #2
00002a  2f01              CMP      r7,#1                 ;512
00002c  d002              BEQ      |L27.52|
;;;533                }
;;;534            }
;;;535            else
;;;536            {
;;;537                /* Get clock divider control register address */
;;;538                if(MODULE_CLKDIV(u32ModuleIdx) == 2U)
00002e  2c02              CMP      r4,#2
000030  d00d              BEQ      |L27.78|
000032  e001              B        |L27.56|
                  |L27.52|
000034  2c02              CMP      r4,#2                 ;514
000036  d002              BEQ      |L27.62|
                  |L27.56|
;;;539                {
;;;540                    u32div = (uint32_t)&CLK->CLKDIV3;
;;;541                }
;;;542                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
000038  07ac              LSLS     r4,r5,#30
00003a  d00a              BEQ      |L27.82|
00003c  e00a              B        |L27.84|
                  |L27.62|
00003e  43c3              MVNS     r3,r0                 ;514
000040  06dc              LSLS     r4,r3,#27             ;514
000042  4b13              LDR      r3,|L27.144|
000044  d006              BEQ      |L27.84|
000046  f000041f          AND      r4,r0,#0x1f           ;518
00004a  2c1d              CMP      r4,#0x1d              ;518
00004c  d002              BEQ      |L27.84|
                  |L27.78|
00004e  4663              MOV      r3,r12                ;540
000050  e000              B        |L27.84|
                  |L27.82|
;;;543                {
;;;544                    u32div = (uint32_t)&CLK->CLKDIV4;
000052  4633              MOV      r3,r6
                  |L27.84|
;;;545                }
;;;546                else
;;;547                {
;;;548                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
;;;549                }
;;;550            }
;;;551    
;;;552            /* Apply new divider */
;;;553            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000054  681c              LDR      r4,[r3,#0]
000056  f3c02587          UBFX     r5,r0,#10,#8
00005a  f3c01644          UBFX     r6,r0,#5,#5
00005e  40b5              LSLS     r5,r5,r6
000060  43ac              BICS     r4,r4,r5
000062  4314              ORRS     r4,r4,r2
000064  601c              STR      r4,[r3,#0]
                  |L27.102|
;;;554        }
;;;555    
;;;556        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000066  0e42              LSRS     r2,r0,#25
000068  0752              LSLS     r2,r2,#29
00006a  d00e              BEQ      |L27.138|
;;;557        {
;;;558            /* Get clock select control register address */
;;;559            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4U);
00006c  4b08              LDR      r3,|L27.144|
00006e  f3c07201          UBFX     r2,r0,#28,#2
000072  3b18              SUBS     r3,r3,#0x18
000074  eb030282          ADD      r2,r3,r2,LSL #2
;;;560            /* Set new clock selection setting */
;;;561            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000078  6813              LDR      r3,[r2,#0]
00007a  f3c06442          UBFX     r4,r0,#25,#3
00007e  f3c05004          UBFX     r0,r0,#20,#5
000082  4084              LSLS     r4,r4,r0
000084  43a3              BICS     r3,r3,r4
000086  430b              ORRS     r3,r3,r1
000088  6013              STR      r3,[r2,#0]
                  |L27.138|
;;;562        }
;;;563    }
00008a  bdf0              POP      {r4-r7,pc}
;;;564    
                          ENDP

                  |L27.140|
                          DCD      0x4000022c
                  |L27.144|
                          DCD      0x40000228

                          AREA ||i.CLK_SetPowerDownMode||, CODE, READONLY, ALIGN=1

                  CLK_SetPowerDownMode PROC
;;;1050   
;;;1051   void CLK_SetPowerDownMode(uint32_t u32PDMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1052   {
;;;1053       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000002  f04f4580          MOV      r5,#0x40000000
000006  4604              MOV      r4,r0                 ;1052
000008  f8d501f4          LDR      r0,[r5,#0x1f4]
00000c  b2c0              UXTB     r0,r0
00000e  2801              CMP      r0,#1
000010  d004              BEQ      |L28.28|
;;;1054       {
;;;1055           if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD0)
;;;1056           {
;;;1057               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1058               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_16K;
;;;1059           }
;;;1060           else if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD1)
;;;1061           {
;;;1062               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1063               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_NO;
;;;1064           }
;;;1065       }
;;;1066       else
;;;1067       {
;;;1068           /* Enable LIRC clock before entering to Standby Power-down Mode */
;;;1069           if((u32PDMode == CLK_PMUCTL_PDMSEL_SPD0) || (u32PDMode == CLK_PMUCTL_PDMSEL_SPD1))
000012  2c04              CMP      r4,#4
000014  d016              BEQ      |L28.68|
000016  2c05              CMP      r4,#5
000018  d014              BEQ      |L28.68|
00001a  e01c              B        |L28.86|
                  |L28.28|
00001c  2c04              CMP      r4,#4                 ;1055
00001e  d002              BEQ      |L28.38|
000020  2c05              CMP      r4,#5                 ;1060
000022  d007              BEQ      |L28.52|
000024  e017              B        |L28.86|
                  |L28.38|
000026  f8d50290          LDR      r0,[r5,#0x290]        ;1058
00002a  f0200070          BIC      r0,r0,#0x70           ;1058
00002e  f0400010          ORR      r0,r0,#0x10           ;1058
000032  e004              B        |L28.62|
                  |L28.52|
000034  f8d50290          LDR      r0,[r5,#0x290]        ;1063
000038  2404              MOVS     r4,#4                 ;1062
00003a  f0200070          BIC      r0,r0,#0x70           ;1063
                  |L28.62|
00003e  f8c50290          STR      r0,[r5,#0x290]        ;1063
000042  e008              B        |L28.86|
                  |L28.68|
;;;1070           {
;;;1071               /* Enable LIRC clock */
;;;1072               CLK->PWRCTL |= CLK_PWRCTL_LIRCEN_Msk;
000044  f8d50200          LDR      r0,[r5,#0x200]
000048  f0400008          ORR      r0,r0,#8
00004c  f8c50200          STR      r0,[r5,#0x200]
;;;1073   
;;;1074               /* Wait for LIRC clock stable */
;;;1075               CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
000050  2008              MOVS     r0,#8
000052  f7fffffe          BL       CLK_WaitClockReady
                  |L28.86|
;;;1076           }
;;;1077       }
;;;1078   
;;;1079       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_PDMSEL_Msk)) | u32PDMode;
000056  f8d50290          LDR      r0,[r5,#0x290]
00005a  f0200007          BIC      r0,r0,#7
00005e  4320              ORRS     r0,r0,r4
000060  f8c50290          STR      r0,[r5,#0x290]
;;;1080   }
000064  bd30              POP      {r4,r5,pc}
;;;1081   
                          ENDP


                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=1

                  CLK_SetSysTickClockSrc PROC
;;;576      */
;;;577    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  f04f4180          MOV      r1,#0x40000000
;;;578    {
;;;579        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4302              ORRS     r2,r2,r0
00000e  f8c12210          STR      r2,[r1,#0x210]
;;;580    
;;;581    }
000012  4770              BX       lr
;;;582    
                          ENDP


                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;963      */
;;;964    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b570              PUSH     {r4-r6,lr}
;;;965    {
000002  4605              MOV      r5,r0
;;;966        uint32_t u32TimeOutCnt = SystemCoreClock / 2;
000004  480b              LDR      r0,|L30.52|
;;;967        uint32_t u32Ret = 1U;
;;;968    
;;;969        g_CLK_i32ErrCode = 0;
000006  4e0c              LDR      r6,|L30.56|
000008  2401              MOVS     r4,#1                 ;967
00000a  6800              LDR      r0,[r0,#0]            ;966  ; SystemCoreClock
00000c  0841              LSRS     r1,r0,#1              ;966
00000e  2000              MOVS     r0,#0
;;;970        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000010  07a2              LSLS     r2,r4,#30
000012  6030              STR      r0,[r6,#0]            ;965  ; g_CLK_i32ErrCode
000014  e001              B        |L30.26|
                  |L30.22|
000016  1e49              SUBS     r1,r1,#1              ;965
;;;971        {
;;;972            if(--u32TimeOutCnt == 0)
000018  d006              BEQ      |L30.40|
                  |L30.26|
00001a  f8d23250          LDR      r3,[r2,#0x250]        ;970
00001e  ea350003          BICS     r0,r5,r3              ;970
000022  d1f8              BNE      |L30.22|
;;;973            {
;;;974                u32Ret = 0U;
;;;975                break;
;;;976            }
;;;977        }
;;;978    
;;;979        if(u32TimeOutCnt == 0)
000024  b109              CBZ      r1,|L30.42|
000026  e003              B        |L30.48|
                  |L30.40|
000028  2400              MOVS     r4,#0                 ;974
                  |L30.42|
;;;980            g_CLK_i32ErrCode = CLK_TIMEOUT_ERR;
00002a  f04f30ff          MOV      r0,#0xffffffff
00002e  6030              STR      r0,[r6,#0]  ; g_CLK_i32ErrCode
                  |L30.48|
;;;981    
;;;982        return u32Ret;
000030  4620              MOV      r0,r4
;;;983    }
000032  bd70              POP      {r4-r6,pc}
;;;984    
                          ENDP

                  |L30.52|
                          DCD      SystemCoreClock
                  |L30.56|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000010

                          AREA ||.data||, DATA, ALIGN=2

                  g_CLK_i32ErrCode
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9a445bc2____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____REVSH|
#line 402
|__asm___5_clk_c_9a445bc2____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____RRX|
#line 587
|__asm___5_clk_c_9a445bc2____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
